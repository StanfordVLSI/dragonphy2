
/****************************************************************
* This code is automatically generated by "mGenero"
* at Thu, 18 Jun 2020 15:53:01.
*
* Copyright (c) 2014-Present by Stanford University. All rights reserved.
*
* The information and source code contained herein is the property
* of Stanford University, and may not be disclosed or reproduced
* in whole or in part without explicit written authorization from
* Stanford University.
* For more information, contact bclim@stanford.edu
****************************************************************/
/********************************************************************
filename: phase_blender.sv
Description: 
multi-bit phase blender.
Assumptions:
Todo:
********************************************************************/

module phase_blender #(
  parameter real placeholder = 42 // placeholder
) (
  input logic  ph_in[0], // ph_in[0]
  input logic  ph_in[1], // ph_in[1]
  output logic  ph_out, // ph_out
  input logic [15:0] thm_sel_bld // thm_sel_bld
);

    timeunit 1fs;
    timeprecision 1fs;

// map pins between generic names and user names, if they are different
 

// Declare parameters
real gain;
real offset;

always @(wakeup) begin
  t0 = `get_time;

$${
digital_modes = [get_lm_equation_modes('test1', 'gain')]
digital_cases = [digital_modes[0][0].keys()]
variable_map = {}
}$$

$$[if not mode_exists('test1')]
  gain = $$get_lm_equation('test1', 'gain');
  offset = $$get_lm_equation('test1', 'offset');
$$[else]
  case({$$(','.join(digital_cases[0]))})
$$[for m in digital_modes[0]]
  {$$(','.join(["%d'b%s" % (Pin.vectorsize(d), dec2bin('%d'%m[d], Pin.vectorsize(d))) for d in digital_cases[0]]))}: begin
    gain = $$get_lm_equation('test1', 'gain', m);
    offset = $$get_lm_equation('test1', 'offset', m);
  end
$$[end for]
  default: begin
    gain = $$get_lm_equation('test1', 'gain', digital_modes[0][0]);
    offset = $$get_lm_equation('test1', 'offset', digital_modes[0][0]);
  end
  endcase
$$[end if]

    real wgt = gain + offset;

    // state variables
    logic nxt_state=1'b0;
    real rise0=-1;
    real fall0=-1;
    real rise1=-1;
    real fall1=-1;

    real ttotr0;
    always @(posedge ph_in[0]) begin
        if (nxt_state != 1'b1) begin
            // update nxt_state
            nxt_state = 1'b1;
            // calculate delay
            if ((rise0 != -1) && (rise1 != -1) && (rise1 >= rise0)) begin
                ttotr0 = wgt*(rise1-rise0) + td + pi_obj.get_rj_mixermb();
            end else begin
                ttotr0 = td + pi_obj.get_rj_mixer1b();
            end
            // schedule output
            ph_out <= #(ttotr0*1s) 1'b1;
        end
        rise0 = $realtime/1s;
    end

    real ttotf0;
    always @(negedge ph_in[0]) begin
        if (nxt_state != 1'b0) begin
            nxt_state = 1'b0;
            if ((fall0 != -1) && (fall1 != -1) && (fall1 >= fall0)) begin
                ttotf0 = wgt*(fall1-fall0) + td + pi_obj.get_rj_mixermb();
            end else begin
                ttotf0 = td + pi_obj.get_rj_mixer1b();
            end
            ph_out <= #(ttotf0*1s) 1'b0;
        end
        fall0 = $realtime/1s;
    end

    real ttotr1;
    always @(posedge ph_in[1]) begin
        if (nxt_state != 1'b1) begin
            // update nxt_state
            nxt_state = 1'b1;
            // calculate delay
            if ((rise0 != -1) && (rise1 != -1) && (rise0 >= rise1)) begin
                ttotr1 = (1.0-wgt)*(rise0-rise1) + td + pi_obj.get_rj_mixermb();
            end else begin
                ttotr1 = td + pi_obj.get_rj_mixer1b();
            end
            // schedule output
            ph_out <= #(ttotr1*1s) 1'b1;
        end
        rise1 = $realtime/1s;
    end

    real ttotf1;
    always @(negedge ph_in[1]) begin
        if (nxt_state != 1'b0) begin
            nxt_state = 1'b0;
            if ((fall0 != -1) && (fall1 != -1) && (fall0 >= fall1)) begin
                ttotf1 = (1.0-wgt)*(fall0-fall1) + td + pi_obj.get_rj_mixermb();
            end else begin
                ttotf1 = td + pi_obj.get_rj_mixer1b();
            end
            ph_out <= #(ttotf1*1s) 1'b0;
        end
        fall1 = $realtime/1s;
    end
endmodule
