

/****************************************************************
* This code is automatically generated by "mGenero"
* at Thu, 18 Jun 2020 15:53:01.
*
* Copyright (c) 2014-Present by Stanford University. All rights reserved.
*
* The information and source code contained herein is the property
* of Stanford University, and may not be disclosed or reproduced
* in whole or in part without explicit written authorization from
* Stanford University.
* For more information, contact bclim@stanford.edu
****************************************************************/
/********************************************************************
filename: phase_blender.sv
Description: 
multi-bit phase blender.
Assumptions:
Todo:
********************************************************************/

module phase_blender #(
  parameter real placeholder = 42 // placeholder
) (
  input logic  ph_in[0], // ph_in[0]
  input logic  ph_in[1], // ph_in[1]
  output logic  ph_out, // ph_out
  input logic [15:0] thm_sel_bld // thm_sel_bld
);

    timeunit 1fs;
    timeprecision 1fs;

// map pins between generic names and user names, if they are different
 

// Declare parameters
real gain;
real offset;

always @(wakeup) begin
  t0 = `get_time;

  gain = 0.0625*thm_sel_bld[8]+0.0625*thm_sel_bld[6]+0.0625*thm_sel_bld[10]+0.0625*thm_sel_bld[11]+0.0625*thm_sel_bld[7]+0.0625*thm_sel_bld[9]+0.0625*thm_sel_bld[4]+0.0625*thm_sel_bld[12]+0.0625*thm_sel_bld[13]+0.0625*thm_sel_bld[5]+0.0625*thm_sel_bld[3]+0.0625*thm_sel_bld[2]+0.0625*thm_sel_bld[0]+0.0625*thm_sel_bld[15]+0.0625*thm_sel_bld[14]+0.0625*thm_sel_bld[1];
  offset = 0.2*(1.0);

    real wgt = gain + offset;

    // state variables
    logic nxt_state=1'b0;
    real rise0=-1;
    real fall0=-1;
    real rise1=-1;
    real fall1=-1;

    real ttotr0;
    always @(posedge ph_in[0]) begin
        if (nxt_state != 1'b1) begin
            // update nxt_state
            nxt_state = 1'b1;
            // calculate delay
            if ((rise0 != -1) && (rise1 != -1) && (rise1 >= rise0)) begin
                ttotr0 = wgt*(rise1-rise0) + td + pi_obj.get_rj_mixermb();
            end else begin
                ttotr0 = td + pi_obj.get_rj_mixer1b();
            end
            // schedule output
            ph_out <= #(ttotr0*1s) 1'b1;
        end
        rise0 = $realtime/1s;
    end

    real ttotf0;
    always @(negedge ph_in[0]) begin
        if (nxt_state != 1'b0) begin
            nxt_state = 1'b0;
            if ((fall0 != -1) && (fall1 != -1) && (fall1 >= fall0)) begin
                ttotf0 = wgt*(fall1-fall0) + td + pi_obj.get_rj_mixermb();
            end else begin
                ttotf0 = td + pi_obj.get_rj_mixer1b();
            end
            ph_out <= #(ttotf0*1s) 1'b0;
        end
        fall0 = $realtime/1s;
    end

    real ttotr1;
    always @(posedge ph_in[1]) begin
        if (nxt_state != 1'b1) begin
            // update nxt_state
            nxt_state = 1'b1;
            // calculate delay
            if ((rise0 != -1) && (rise1 != -1) && (rise0 >= rise1)) begin
                ttotr1 = (1.0-wgt)*(rise0-rise1) + td + pi_obj.get_rj_mixermb();
            end else begin
                ttotr1 = td + pi_obj.get_rj_mixer1b();
            end
            // schedule output
            ph_out <= #(ttotr1*1s) 1'b1;
        end
        rise1 = $realtime/1s;
    end

    real ttotf1;
    always @(negedge ph_in[1]) begin
        if (nxt_state != 1'b0) begin
            nxt_state = 1'b0;
            if ((fall0 != -1) && (fall1 != -1) && (fall0 >= fall1)) begin
                ttotf1 = (1.0-wgt)*(fall0-fall1) + td + pi_obj.get_rj_mixermb();
            end else begin
                ttotf1 = td + pi_obj.get_rj_mixer1b();
            end
            ph_out <= #(ttotf1*1s) 1'b0;
        end
        fall1 = $realtime/1s;
    end
endmodule
