//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11879 $ --- $Date: 2013/06/11 $   |
//	-----------------------------------------------
//	
//
//  Source file: /sim/zamyers/JusTAG/rtl/primitives/reg_file.svp
//  Source template: reg_file
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter RegList 	= Data structure of type ARRAY
// Parameter CfgOpcodes 	= Data structure of type HASH
// Parameter BaseAddr 	= 4096
// Parameter CfgBusPtr 	= Data structure of type cfg_ifc
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/* *****************************************************************************
 * File: reg_file.vp
 * 
 * Description:
 * This file is using Genesis2 to make a register file.
 * A register file have a config bus input port, and a config bus output port. 
 * The configuration request values are flopped and then handled:
 * * If cfgIn_op is a no-op, nothing happens.
 * * If cfgIn_op is a bypass op, the  cfgIn_* signals are passed to the 
 *      cfgOut_* ports.
 * * If cfgIn_op is a read/write op, and cfgIn_addr is with in the address
 *      range, then the corresponding register is read/written. The values
 *      are streamed to the cfgOut_* ports, except for cfgOut_op that becomes
 *      a bypass-op.
 *      If cfgIn_addr is not in this reg_file address range, all the  cfgIn_* 
 *      signals are passed to the cfgOut_* ports. Someone else will answer...
 * 
 * Note: All registers in the register file are write-able and readable by the
 *      configuration bus (even though some may only have output ports or only
 *      input ports).
 * 
 * 
 * REQUIRED GENESIS PARAMETERS:
 * ----------------------------
 * * RegList  - List of registers. Each element in the list is a hash that contains
 *    * Name - used for generating the enable and data output/input signals
 *    * Width - register width
 *    * Default - (optional) default value. Can be set later by XML input
 *    * IEO - I indicates this register connected to an input signal
 *            E indicates that the input is qualified by an enable 
 *            O indicates that the output is connected to an output signal
 *            Valid options include: I, IE, O, IO, IEO
 *    * Comment - (optional) description of the register
 *   Example:
 *    my $reg_list = [      
 *        {Name => 'regA', Width => 5, Default => 17, IEO => 'ie', Comment => 'this is a reg'}, 
 *        {Name => 'regB', Width => 10, Default => 27, IEO => 'o'}, 
 *        {Name => 'regC', Width => 15, IEO => 'ieo'},
 *        {Name => 'regD', Width => 13, Default => 4, IEO => 'i'}
 *                   ];
 * 
 * * BaseAddr - Base address for this module 
 * * CfgOpcodes - Interpretation of the opcode. Must contain the following feilds:
 *    * nop - value of cfgIn_op for a no-op (default is 0)
 *    * read - value of cfgIn_op for a read operation (default is 1)
 *    * write - value of cfgIn_op for a write operation (default is 2)
 *    * bypass - value of cfgIn_op for bypassing the control signals (default is 3)
 * * CfgBusPtr - An instance of the reg_file_ifc (used as reference)
 * 
 * Inputs:
 * -------
 * Clk
 * Reset
 * cfgIn - Incomming config request
 * foreach REG in REG_LIST (but depending on the IEO flag):
 *  * <REG.name>_en - enable signal for the register
 *  * <REG.name>_d - data input for the register
 * 
 * Outputs:
 * --------
 * cfgOut - Outgoing reply for config request cfgIn
 * foreach REG in REG_LIST (but depending on the IEO flag):
 *  * <REG.name>_q - data output for the register
 * 
 * 
 * NOTE: registers with input from the design may become resource contention
 *       if both their private enable and their by-address enable signals are raised.
 *       Priority is always given to data from the cfg bus!
 * 
 * ****************************************************************************/

// ACTUAL GENESIS2 PARAMETERIZATIONS
// RegList (_GENESIS2_INHERITANCE_PRIORITY_) = 
//	[ { Default=>0, IEO=>o, Name=>en_v2t, Width=>1 },
//	  { Default=>0xffff, IEO=>o, Name=>en_slice, Width=>16 },
//	  { Default=>0, IEO=>o, Name=>ALWS_ON, Width=>16 },
//	  { Default=>0, IEO=>o, Name=>sel_clk_TDC, Width=>16 },
//	  { Default=>0, IEO=>o, Name=>en_pm, Width=>16 },
//	  { Default=>0, IEO=>o, Name=>en_v2t_clk_next, Width=>16 },
//	  { Default=>0, IEO=>o, Name=>en_sw_test, Width=>16 },
//	  { Default=>1, IEO=>o, Name=>en_gf, Width=>1 },
//	  { Default=>15, IEO=>o, Name=>en_arb_pi, Width=>4 },
//	  { Default=>15, IEO=>o, Name=>en_delay_pi, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>en_ext_Qperi, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>en_pm_pi, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>en_cal_pi, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>disable_state, Width=>4 },
//	  { Default=>15, IEO=>o, Name=>en_clk_sw, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>en_meas_pi, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>sel_meas_pi, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>en_slice_rep, Width=>2 },
//	  { Default=>0, IEO=>o, Name=>ALWS_ON_rep, Width=>2 },
//	  { Default=>0, IEO=>o, Name=>sel_clk_TDC_rep, Width=>2 },
//	  { Default=>0, IEO=>o, Name=>en_pm_rep, Width=>2 },
//	  { Default=>0, IEO=>o, Name=>en_v2t_clk_next_rep, Width=>2 },
//	  { Default=>0, IEO=>o, Name=>en_sw_test_rep, Width=>2 },
//	  { Default=>0, IEO=>o, Name=>sel_pfd_in, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>sel_pfd_in_meas, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>en_pfd_inp_meas, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>en_pfd_inn_meas, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>sel_del_out, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>disable_ibuf_async, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>disable_ibuf_aux, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>disable_ibuf_test0, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>disable_ibuf_test1, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>en_inbuf, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>sel_inbuf_in, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>bypass_inbuf_div, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>inbuf_ndiv, Width=>3 },
//	  { Default=>0, IEO=>o, Name=>en_inbuf_meas, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>en_biasgen, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>sel_del_out_pi, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>en_del_out_pi, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>pd_offset_ext, Width=>8 },
//	  { Default=>0x100, IEO=>o, Name=>i_val, Width=>22 },
//	  { Default=>0x10000, IEO=>o, Name=>p_val, Width=>22 },
//	  { Default=>1, IEO=>o, Name=>en_ext_pi_ctl_cdr, Width=>1 },
//	  { Default=>50, IEO=>o, Name=>ext_pi_ctl_cdr, Width=>9 },
//	  { Default=>1, IEO=>o, Name=>en_ext_pfd_offset, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>en_ext_pfd_offset_rep, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>en_ext_max_sel_mux, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>en_pfd_cal, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>en_pfd_cal_rep, Width=>1 },
//	  { Default=>10, IEO=>o, Name=>Navg_adc, Width=>4 },
//	  { Default=>6, IEO=>o, Name=>Nbin_adc, Width=>4 },
//	  { Default=>3, IEO=>o, Name=>DZ_hist_adc, Width=>4 },
//	  { Default=>10, IEO=>o, Name=>Navg_adc_rep, Width=>4 },
//	  { Default=>6, IEO=>o, Name=>Nbin_adc_rep, Width=>4 },
//	  { Default=>3, IEO=>o, Name=>DZ_hist_adc_rep, Width=>4 },
//	  { Default=>10, IEO=>o, Name=>Ndiv_clk_avg, Width=>4 },
//	  { Default=>4, IEO=>o, Name=>Ndiv_clk_cdr, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>int_rstb, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>sram_rstb, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>cdr_rstb, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>sel_outbuff, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>sel_trigbuff, Width=>4 },
//	  { Default=>0, IEO=>o, Name=>en_outbuff, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>en_trigbuff, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>Ndiv_outbuff, Width=>3 },
//	  { Default=>0, IEO=>o, Name=>Ndiv_trigbuff, Width=>3 },
//	  { Default=>1, IEO=>o, Name=>bypass_out, Width=>1 },
//	  { Default=>1, IEO=>o, Name=>bypass_trig, Width=>1 },
//	  { Default=>0, IEO=>o, Name=>in_addr, Width=>10 }
//	]
//
// BaseAddr (_GENESIS2_INHERITANCE_PRIORITY_) = 0x1000
//
// CfgOpcodes (_GENESIS2_INHERITANCE_PRIORITY_) = 
//	{ bypass=>3, nop=>0, read=>1, write=>2 }
//
// CfgBusPtr (_GENESIS2_INHERITANCE_PRIORITY_) = 
//	InstancePath:raw_jtag.tc_jtag2rf0_ifc (cfg_ifc_unq1)
//

// Fix for reg files with single registers
// 13:9
// 5
// 8
// 5'h8
// =============================================================================
//                  LIST OF REGISTERS IN THIS MODULE:
// =============================================================================
// LEGEND: 
//      BaseAddr 'h1000
//      IEO:  I for input (register samples design)
//            O for output (register drives design)
//            IE for enabled input (register samples design if enable is high)
//
// REGISTERS
// en_v2t [0:0] IEO=o Offset=0 -- 
// en_slice [15:0] IEO=o Offset=4 -- 
// ALWS_ON [15:0] IEO=o Offset=8 -- 
// sel_clk_TDC [15:0] IEO=o Offset=12 -- 
// en_pm [15:0] IEO=o Offset=16 -- 
// en_v2t_clk_next [15:0] IEO=o Offset=20 -- 
// en_sw_test [15:0] IEO=o Offset=24 -- 
// en_gf [0:0] IEO=o Offset=28 -- 
// en_arb_pi [3:0] IEO=o Offset=32 -- 
// en_delay_pi [3:0] IEO=o Offset=36 -- 
// en_ext_Qperi [3:0] IEO=o Offset=40 -- 
// en_pm_pi [3:0] IEO=o Offset=44 -- 
// en_cal_pi [3:0] IEO=o Offset=48 -- 
// disable_state [3:0] IEO=o Offset=52 -- 
// en_clk_sw [3:0] IEO=o Offset=56 -- 
// en_meas_pi [3:0] IEO=o Offset=60 -- 
// sel_meas_pi [3:0] IEO=o Offset=64 -- 
// en_slice_rep [1:0] IEO=o Offset=68 -- 
// ALWS_ON_rep [1:0] IEO=o Offset=72 -- 
// sel_clk_TDC_rep [1:0] IEO=o Offset=76 -- 
// en_pm_rep [1:0] IEO=o Offset=80 -- 
// en_v2t_clk_next_rep [1:0] IEO=o Offset=84 -- 
// en_sw_test_rep [1:0] IEO=o Offset=88 -- 
// sel_pfd_in [0:0] IEO=o Offset=92 -- 
// sel_pfd_in_meas [0:0] IEO=o Offset=96 -- 
// en_pfd_inp_meas [0:0] IEO=o Offset=100 -- 
// en_pfd_inn_meas [0:0] IEO=o Offset=104 -- 
// sel_del_out [0:0] IEO=o Offset=108 -- 
// disable_ibuf_async [0:0] IEO=o Offset=112 -- 
// disable_ibuf_aux [0:0] IEO=o Offset=116 -- 
// disable_ibuf_test0 [0:0] IEO=o Offset=120 -- 
// disable_ibuf_test1 [0:0] IEO=o Offset=124 -- 
// en_inbuf [0:0] IEO=o Offset=128 -- 
// sel_inbuf_in [0:0] IEO=o Offset=132 -- 
// bypass_inbuf_div [0:0] IEO=o Offset=136 -- 
// inbuf_ndiv [2:0] IEO=o Offset=140 -- 
// en_inbuf_meas [0:0] IEO=o Offset=144 -- 
// en_biasgen [3:0] IEO=o Offset=148 -- 
// sel_del_out_pi [0:0] IEO=o Offset=152 -- 
// en_del_out_pi [0:0] IEO=o Offset=156 -- 
// pd_offset_ext [7:0] IEO=o Offset=160 -- 
// i_val [21:0] IEO=o Offset=164 -- 
// p_val [21:0] IEO=o Offset=168 -- 
// en_ext_pi_ctl_cdr [0:0] IEO=o Offset=172 -- 
// ext_pi_ctl_cdr [8:0] IEO=o Offset=176 -- 
// en_ext_pfd_offset [0:0] IEO=o Offset=180 -- 
// en_ext_pfd_offset_rep [0:0] IEO=o Offset=184 -- 
// en_ext_max_sel_mux [0:0] IEO=o Offset=188 -- 
// en_pfd_cal [0:0] IEO=o Offset=192 -- 
// en_pfd_cal_rep [0:0] IEO=o Offset=196 -- 
// Navg_adc [3:0] IEO=o Offset=200 -- 
// Nbin_adc [3:0] IEO=o Offset=204 -- 
// DZ_hist_adc [3:0] IEO=o Offset=208 -- 
// Navg_adc_rep [3:0] IEO=o Offset=212 -- 
// Nbin_adc_rep [3:0] IEO=o Offset=216 -- 
// DZ_hist_adc_rep [3:0] IEO=o Offset=220 -- 
// Ndiv_clk_avg [3:0] IEO=o Offset=224 -- 
// Ndiv_clk_cdr [3:0] IEO=o Offset=228 -- 
// int_rstb [0:0] IEO=o Offset=232 -- 
// sram_rstb [0:0] IEO=o Offset=236 -- 
// cdr_rstb [0:0] IEO=o Offset=240 -- 
// sel_outbuff [3:0] IEO=o Offset=244 -- 
// sel_trigbuff [3:0] IEO=o Offset=248 -- 
// en_outbuff [0:0] IEO=o Offset=252 -- 
// en_trigbuff [0:0] IEO=o Offset=256 -- 
// Ndiv_outbuff [2:0] IEO=o Offset=260 -- 
// Ndiv_trigbuff [2:0] IEO=o Offset=264 -- 
// bypass_out [0:0] IEO=o Offset=268 -- 
// bypass_trig [0:0] IEO=o Offset=272 -- 
// in_addr [9:0] IEO=o Offset=276 -- 




// =============================================================================
//                             MODULE:
// =============================================================================
module reg_file_unq18
  (
   // inputs for the config interface
   cfg_ifc_unq1.cfgIn cfgIn, // incoming requests
   cfg_ifc_unq1.cfgOut cfgOut, // outgoing responds


   //outputs
    // outputs for register en_v2t
    output wire logic[0:0]       en_v2t_q,
                           
    // outputs for register en_slice
    output wire logic[15:0]       en_slice_q,
                           
    // outputs for register ALWS_ON
    output wire logic[15:0]       ALWS_ON_q,
                           
    // outputs for register sel_clk_TDC
    output wire logic[15:0]       sel_clk_TDC_q,
                           
    // outputs for register en_pm
    output wire logic[15:0]       en_pm_q,
                           
    // outputs for register en_v2t_clk_next
    output wire logic[15:0]       en_v2t_clk_next_q,
                           
    // outputs for register en_sw_test
    output wire logic[15:0]       en_sw_test_q,
                           
    // outputs for register en_gf
    output wire logic[0:0]       en_gf_q,
                           
    // outputs for register en_arb_pi
    output wire logic[3:0]       en_arb_pi_q,
                           
    // outputs for register en_delay_pi
    output wire logic[3:0]       en_delay_pi_q,
                           
    // outputs for register en_ext_Qperi
    output wire logic[3:0]       en_ext_Qperi_q,
                           
    // outputs for register en_pm_pi
    output wire logic[3:0]       en_pm_pi_q,
                           
    // outputs for register en_cal_pi
    output wire logic[3:0]       en_cal_pi_q,
                           
    // outputs for register disable_state
    output wire logic[3:0]       disable_state_q,
                           
    // outputs for register en_clk_sw
    output wire logic[3:0]       en_clk_sw_q,
                           
    // outputs for register en_meas_pi
    output wire logic[3:0]       en_meas_pi_q,
                           
    // outputs for register sel_meas_pi
    output wire logic[3:0]       sel_meas_pi_q,
                           
    // outputs for register en_slice_rep
    output wire logic[1:0]       en_slice_rep_q,
                           
    // outputs for register ALWS_ON_rep
    output wire logic[1:0]       ALWS_ON_rep_q,
                           
    // outputs for register sel_clk_TDC_rep
    output wire logic[1:0]       sel_clk_TDC_rep_q,
                           
    // outputs for register en_pm_rep
    output wire logic[1:0]       en_pm_rep_q,
                           
    // outputs for register en_v2t_clk_next_rep
    output wire logic[1:0]       en_v2t_clk_next_rep_q,
                           
    // outputs for register en_sw_test_rep
    output wire logic[1:0]       en_sw_test_rep_q,
                           
    // outputs for register sel_pfd_in
    output wire logic[0:0]       sel_pfd_in_q,
                           
    // outputs for register sel_pfd_in_meas
    output wire logic[0:0]       sel_pfd_in_meas_q,
                           
    // outputs for register en_pfd_inp_meas
    output wire logic[0:0]       en_pfd_inp_meas_q,
                           
    // outputs for register en_pfd_inn_meas
    output wire logic[0:0]       en_pfd_inn_meas_q,
                           
    // outputs for register sel_del_out
    output wire logic[0:0]       sel_del_out_q,
                           
    // outputs for register disable_ibuf_async
    output wire logic[0:0]       disable_ibuf_async_q,
                           
    // outputs for register disable_ibuf_aux
    output wire logic[0:0]       disable_ibuf_aux_q,
                           
    // outputs for register disable_ibuf_test0
    output wire logic[0:0]       disable_ibuf_test0_q,
                           
    // outputs for register disable_ibuf_test1
    output wire logic[0:0]       disable_ibuf_test1_q,
                           
    // outputs for register en_inbuf
    output wire logic[0:0]       en_inbuf_q,
                           
    // outputs for register sel_inbuf_in
    output wire logic[0:0]       sel_inbuf_in_q,
                           
    // outputs for register bypass_inbuf_div
    output wire logic[0:0]       bypass_inbuf_div_q,
                           
    // outputs for register inbuf_ndiv
    output wire logic[2:0]       inbuf_ndiv_q,
                           
    // outputs for register en_inbuf_meas
    output wire logic[0:0]       en_inbuf_meas_q,
                           
    // outputs for register en_biasgen
    output wire logic[3:0]       en_biasgen_q,
                           
    // outputs for register sel_del_out_pi
    output wire logic[0:0]       sel_del_out_pi_q,
                           
    // outputs for register en_del_out_pi
    output wire logic[0:0]       en_del_out_pi_q,
                           
    // outputs for register pd_offset_ext
    output wire logic[7:0]       pd_offset_ext_q,
                           
    // outputs for register i_val
    output wire logic[21:0]       i_val_q,
                           
    // outputs for register p_val
    output wire logic[21:0]       p_val_q,
                           
    // outputs for register en_ext_pi_ctl_cdr
    output wire logic[0:0]       en_ext_pi_ctl_cdr_q,
                           
    // outputs for register ext_pi_ctl_cdr
    output wire logic[8:0]       ext_pi_ctl_cdr_q,
                           
    // outputs for register en_ext_pfd_offset
    output wire logic[0:0]       en_ext_pfd_offset_q,
                           
    // outputs for register en_ext_pfd_offset_rep
    output wire logic[0:0]       en_ext_pfd_offset_rep_q,
                           
    // outputs for register en_ext_max_sel_mux
    output wire logic[0:0]       en_ext_max_sel_mux_q,
                           
    // outputs for register en_pfd_cal
    output wire logic[0:0]       en_pfd_cal_q,
                           
    // outputs for register en_pfd_cal_rep
    output wire logic[0:0]       en_pfd_cal_rep_q,
                           
    // outputs for register Navg_adc
    output wire logic[3:0]       Navg_adc_q,
                           
    // outputs for register Nbin_adc
    output wire logic[3:0]       Nbin_adc_q,
                           
    // outputs for register DZ_hist_adc
    output wire logic[3:0]       DZ_hist_adc_q,
                           
    // outputs for register Navg_adc_rep
    output wire logic[3:0]       Navg_adc_rep_q,
                           
    // outputs for register Nbin_adc_rep
    output wire logic[3:0]       Nbin_adc_rep_q,
                           
    // outputs for register DZ_hist_adc_rep
    output wire logic[3:0]       DZ_hist_adc_rep_q,
                           
    // outputs for register Ndiv_clk_avg
    output wire logic[3:0]       Ndiv_clk_avg_q,
                           
    // outputs for register Ndiv_clk_cdr
    output wire logic[3:0]       Ndiv_clk_cdr_q,
                           
    // outputs for register int_rstb
    output wire logic[0:0]       int_rstb_q,
                           
    // outputs for register sram_rstb
    output wire logic[0:0]       sram_rstb_q,
                           
    // outputs for register cdr_rstb
    output wire logic[0:0]       cdr_rstb_q,
                           
    // outputs for register sel_outbuff
    output wire logic[3:0]       sel_outbuff_q,
                           
    // outputs for register sel_trigbuff
    output wire logic[3:0]       sel_trigbuff_q,
                           
    // outputs for register en_outbuff
    output wire logic[0:0]       en_outbuff_q,
                           
    // outputs for register en_trigbuff
    output wire logic[0:0]       en_trigbuff_q,
                           
    // outputs for register Ndiv_outbuff
    output wire logic[2:0]       Ndiv_outbuff_q,
                           
    // outputs for register Ndiv_trigbuff
    output wire logic[2:0]       Ndiv_trigbuff_q,
                           
    // outputs for register bypass_out
    output wire logic[0:0]       bypass_out_q,
                           
    // outputs for register bypass_trig
    output wire logic[0:0]       bypass_trig_q,
                           
    // outputs for register in_addr
    output wire logic[9:0]       in_addr_q,
                           
   
   // Generic inputs 
    input wire logic			       Clk,
    input wire logic                        Reset
   );


   // floping cfg inputs to produce delayed signals:
   logic [13:0]       cfgIn_addr_del;
   logic [31:0]        cfgIn_data_del;
   logic [1:0]         cfgIn_op_del;
   flop_unq5  cfgIn_floper (.Clk(Clk), .Reset(Reset), 
			      .din({cfgIn.addr, cfgIn.data, cfgIn.op}),
			      .dout({cfgIn_addr_del, cfgIn_data_del, cfgIn_op_del}));



   // internal wiring signals
   logic [69:0]             onehot_en;
   logic                               addr_in_range;
   logic [6:0]    cfgIn_addr_del_int; // internal (shorter) address signal
   logic [69:0]             regs_en;
   logic [31:0]        regs_d[69:0];
   logic [31:0]        regs_q[69:0];

   // make sure that the input address is in range
   assign addr_in_range = ((5'h8 == cfgIn_addr_del[13:9]) &&
                     (cfgIn_addr_del[8:2] < 8'd70))? 1'b1: 1'b0;
   
   // Pick the right bits of the address signal (if out of range default to zero)
   assign cfgIn_addr_del_int[6:0] = (addr_in_range)? cfgIn_addr_del[8:2]: 7'b0;
   
   // For config writes, there can be at most onehot enable signal
   always_comb begin
      onehot_en = 1'b0;
      onehot_en[cfgIn_addr_del_int] = (cfgIn_op_del == 2) && (addr_in_range == 1'b1);
   end

   // assign the config output ports
   assign cfgOut.data = (addr_in_range != 1'b1) ? cfgIn_data_del : // if not in range, pass the signal to the next guy
                  (cfgIn_op_del == 1) ? regs_q[cfgIn_addr_del_int] : // if in range and this is a readop... read
                  cfgIn_data_del;
   assign cfgOut.addr = cfgIn_addr_del;
   assign cfgOut.op = (addr_in_range != 1'b1) ? cfgIn_op_del : // if not in range pass the signal to next guy
                  (cfgIn_op_del != 0) ? 2'd3:      // if in range (and not a nop) mark as done (bypass)
                  2'd0;                              // else, it's just a nop.
      

   // Instantiate all the registers:
   // ==============================
   // register #0 --- name:en_v2t, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[0] = onehot_en[0]; 
   // input only from cfg bus
   assign regs_d[0][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_v2t_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[0]),
      .din(regs_d[0][0:0]), .dout(regs_q[0][0:0]));

   // assign value to the relevant output
   assign en_v2t_q[0:0] = regs_q[0][0:0]; 
   // pad the config bus with zeros
   assign regs_q[0][31:1] = '0; 
   
   // register #1 --- name:en_slice, type:o, Width:16
   // flop input only on cfg writes
   assign regs_en[1] = onehot_en[1]; 
   // input only from cfg bus
   assign regs_d[1][15:0] = cfgIn_data_del[15:0]; 
   flop_unq14  en_slice_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[1]),
      .din(regs_d[1][15:0]), .dout(regs_q[1][15:0]));

   // assign value to the relevant output
   assign en_slice_q[15:0] = regs_q[1][15:0]; 
   // pad the config bus with zeros
   assign regs_q[1][31:16] = '0; 
   
   // register #2 --- name:ALWS_ON, type:o, Width:16
   // flop input only on cfg writes
   assign regs_en[2] = onehot_en[2]; 
   // input only from cfg bus
   assign regs_d[2][15:0] = cfgIn_data_del[15:0]; 
   flop_unq12  ALWS_ON_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[2]),
      .din(regs_d[2][15:0]), .dout(regs_q[2][15:0]));

   // assign value to the relevant output
   assign ALWS_ON_q[15:0] = regs_q[2][15:0]; 
   // pad the config bus with zeros
   assign regs_q[2][31:16] = '0; 
   
   // register #3 --- name:sel_clk_TDC, type:o, Width:16
   // flop input only on cfg writes
   assign regs_en[3] = onehot_en[3]; 
   // input only from cfg bus
   assign regs_d[3][15:0] = cfgIn_data_del[15:0]; 
   flop_unq12  sel_clk_TDC_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[3]),
      .din(regs_d[3][15:0]), .dout(regs_q[3][15:0]));

   // assign value to the relevant output
   assign sel_clk_TDC_q[15:0] = regs_q[3][15:0]; 
   // pad the config bus with zeros
   assign regs_q[3][31:16] = '0; 
   
   // register #4 --- name:en_pm, type:o, Width:16
   // flop input only on cfg writes
   assign regs_en[4] = onehot_en[4]; 
   // input only from cfg bus
   assign regs_d[4][15:0] = cfgIn_data_del[15:0]; 
   flop_unq12  en_pm_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[4]),
      .din(regs_d[4][15:0]), .dout(regs_q[4][15:0]));

   // assign value to the relevant output
   assign en_pm_q[15:0] = regs_q[4][15:0]; 
   // pad the config bus with zeros
   assign regs_q[4][31:16] = '0; 
   
   // register #5 --- name:en_v2t_clk_next, type:o, Width:16
   // flop input only on cfg writes
   assign regs_en[5] = onehot_en[5]; 
   // input only from cfg bus
   assign regs_d[5][15:0] = cfgIn_data_del[15:0]; 
   flop_unq12  en_v2t_clk_next_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[5]),
      .din(regs_d[5][15:0]), .dout(regs_q[5][15:0]));

   // assign value to the relevant output
   assign en_v2t_clk_next_q[15:0] = regs_q[5][15:0]; 
   // pad the config bus with zeros
   assign regs_q[5][31:16] = '0; 
   
   // register #6 --- name:en_sw_test, type:o, Width:16
   // flop input only on cfg writes
   assign regs_en[6] = onehot_en[6]; 
   // input only from cfg bus
   assign regs_d[6][15:0] = cfgIn_data_del[15:0]; 
   flop_unq12  en_sw_test_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[6]),
      .din(regs_d[6][15:0]), .dout(regs_q[6][15:0]));

   // assign value to the relevant output
   assign en_sw_test_q[15:0] = regs_q[6][15:0]; 
   // pad the config bus with zeros
   assign regs_q[6][31:16] = '0; 
   
   // register #7 --- name:en_gf, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[7] = onehot_en[7]; 
   // input only from cfg bus
   assign regs_d[7][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  en_gf_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[7]),
      .din(regs_d[7][0:0]), .dout(regs_q[7][0:0]));

   // assign value to the relevant output
   assign en_gf_q[0:0] = regs_q[7][0:0]; 
   // pad the config bus with zeros
   assign regs_q[7][31:1] = '0; 
   
   // register #8 --- name:en_arb_pi, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[8] = onehot_en[8]; 
   // input only from cfg bus
   assign regs_d[8][3:0] = cfgIn_data_del[3:0]; 
   flop_unq16  en_arb_pi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[8]),
      .din(regs_d[8][3:0]), .dout(regs_q[8][3:0]));

   // assign value to the relevant output
   assign en_arb_pi_q[3:0] = regs_q[8][3:0]; 
   // pad the config bus with zeros
   assign regs_q[8][31:4] = '0; 
   
   // register #9 --- name:en_delay_pi, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[9] = onehot_en[9]; 
   // input only from cfg bus
   assign regs_d[9][3:0] = cfgIn_data_del[3:0]; 
   flop_unq16  en_delay_pi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[9]),
      .din(regs_d[9][3:0]), .dout(regs_q[9][3:0]));

   // assign value to the relevant output
   assign en_delay_pi_q[3:0] = regs_q[9][3:0]; 
   // pad the config bus with zeros
   assign regs_q[9][31:4] = '0; 
   
   // register #10 --- name:en_ext_Qperi, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[10] = onehot_en[10]; 
   // input only from cfg bus
   assign regs_d[10][3:0] = cfgIn_data_del[3:0]; 
   flop_unq6  en_ext_Qperi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[10]),
      .din(regs_d[10][3:0]), .dout(regs_q[10][3:0]));

   // assign value to the relevant output
   assign en_ext_Qperi_q[3:0] = regs_q[10][3:0]; 
   // pad the config bus with zeros
   assign regs_q[10][31:4] = '0; 
   
   // register #11 --- name:en_pm_pi, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[11] = onehot_en[11]; 
   // input only from cfg bus
   assign regs_d[11][3:0] = cfgIn_data_del[3:0]; 
   flop_unq6  en_pm_pi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[11]),
      .din(regs_d[11][3:0]), .dout(regs_q[11][3:0]));

   // assign value to the relevant output
   assign en_pm_pi_q[3:0] = regs_q[11][3:0]; 
   // pad the config bus with zeros
   assign regs_q[11][31:4] = '0; 
   
   // register #12 --- name:en_cal_pi, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[12] = onehot_en[12]; 
   // input only from cfg bus
   assign regs_d[12][3:0] = cfgIn_data_del[3:0]; 
   flop_unq6  en_cal_pi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[12]),
      .din(regs_d[12][3:0]), .dout(regs_q[12][3:0]));

   // assign value to the relevant output
   assign en_cal_pi_q[3:0] = regs_q[12][3:0]; 
   // pad the config bus with zeros
   assign regs_q[12][31:4] = '0; 
   
   // register #13 --- name:disable_state, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[13] = onehot_en[13]; 
   // input only from cfg bus
   assign regs_d[13][3:0] = cfgIn_data_del[3:0]; 
   flop_unq6  disable_state_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[13]),
      .din(regs_d[13][3:0]), .dout(regs_q[13][3:0]));

   // assign value to the relevant output
   assign disable_state_q[3:0] = regs_q[13][3:0]; 
   // pad the config bus with zeros
   assign regs_q[13][31:4] = '0; 
   
   // register #14 --- name:en_clk_sw, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[14] = onehot_en[14]; 
   // input only from cfg bus
   assign regs_d[14][3:0] = cfgIn_data_del[3:0]; 
   flop_unq16  en_clk_sw_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[14]),
      .din(regs_d[14][3:0]), .dout(regs_q[14][3:0]));

   // assign value to the relevant output
   assign en_clk_sw_q[3:0] = regs_q[14][3:0]; 
   // pad the config bus with zeros
   assign regs_q[14][31:4] = '0; 
   
   // register #15 --- name:en_meas_pi, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[15] = onehot_en[15]; 
   // input only from cfg bus
   assign regs_d[15][3:0] = cfgIn_data_del[3:0]; 
   flop_unq6  en_meas_pi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[15]),
      .din(regs_d[15][3:0]), .dout(regs_q[15][3:0]));

   // assign value to the relevant output
   assign en_meas_pi_q[3:0] = regs_q[15][3:0]; 
   // pad the config bus with zeros
   assign regs_q[15][31:4] = '0; 
   
   // register #16 --- name:sel_meas_pi, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[16] = onehot_en[16]; 
   // input only from cfg bus
   assign regs_d[16][3:0] = cfgIn_data_del[3:0]; 
   flop_unq6  sel_meas_pi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[16]),
      .din(regs_d[16][3:0]), .dout(regs_q[16][3:0]));

   // assign value to the relevant output
   assign sel_meas_pi_q[3:0] = regs_q[16][3:0]; 
   // pad the config bus with zeros
   assign regs_q[16][31:4] = '0; 
   
   // register #17 --- name:en_slice_rep, type:o, Width:2
   // flop input only on cfg writes
   assign regs_en[17] = onehot_en[17]; 
   // input only from cfg bus
   assign regs_d[17][1:0] = cfgIn_data_del[1:0]; 
   flop_unq1  en_slice_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[17]),
      .din(regs_d[17][1:0]), .dout(regs_q[17][1:0]));

   // assign value to the relevant output
   assign en_slice_rep_q[1:0] = regs_q[17][1:0]; 
   // pad the config bus with zeros
   assign regs_q[17][31:2] = '0; 
   
   // register #18 --- name:ALWS_ON_rep, type:o, Width:2
   // flop input only on cfg writes
   assign regs_en[18] = onehot_en[18]; 
   // input only from cfg bus
   assign regs_d[18][1:0] = cfgIn_data_del[1:0]; 
   flop_unq1  ALWS_ON_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[18]),
      .din(regs_d[18][1:0]), .dout(regs_q[18][1:0]));

   // assign value to the relevant output
   assign ALWS_ON_rep_q[1:0] = regs_q[18][1:0]; 
   // pad the config bus with zeros
   assign regs_q[18][31:2] = '0; 
   
   // register #19 --- name:sel_clk_TDC_rep, type:o, Width:2
   // flop input only on cfg writes
   assign regs_en[19] = onehot_en[19]; 
   // input only from cfg bus
   assign regs_d[19][1:0] = cfgIn_data_del[1:0]; 
   flop_unq1  sel_clk_TDC_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[19]),
      .din(regs_d[19][1:0]), .dout(regs_q[19][1:0]));

   // assign value to the relevant output
   assign sel_clk_TDC_rep_q[1:0] = regs_q[19][1:0]; 
   // pad the config bus with zeros
   assign regs_q[19][31:2] = '0; 
   
   // register #20 --- name:en_pm_rep, type:o, Width:2
   // flop input only on cfg writes
   assign regs_en[20] = onehot_en[20]; 
   // input only from cfg bus
   assign regs_d[20][1:0] = cfgIn_data_del[1:0]; 
   flop_unq1  en_pm_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[20]),
      .din(regs_d[20][1:0]), .dout(regs_q[20][1:0]));

   // assign value to the relevant output
   assign en_pm_rep_q[1:0] = regs_q[20][1:0]; 
   // pad the config bus with zeros
   assign regs_q[20][31:2] = '0; 
   
   // register #21 --- name:en_v2t_clk_next_rep, type:o, Width:2
   // flop input only on cfg writes
   assign regs_en[21] = onehot_en[21]; 
   // input only from cfg bus
   assign regs_d[21][1:0] = cfgIn_data_del[1:0]; 
   flop_unq1  en_v2t_clk_next_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[21]),
      .din(regs_d[21][1:0]), .dout(regs_q[21][1:0]));

   // assign value to the relevant output
   assign en_v2t_clk_next_rep_q[1:0] = regs_q[21][1:0]; 
   // pad the config bus with zeros
   assign regs_q[21][31:2] = '0; 
   
   // register #22 --- name:en_sw_test_rep, type:o, Width:2
   // flop input only on cfg writes
   assign regs_en[22] = onehot_en[22]; 
   // input only from cfg bus
   assign regs_d[22][1:0] = cfgIn_data_del[1:0]; 
   flop_unq1  en_sw_test_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[22]),
      .din(regs_d[22][1:0]), .dout(regs_q[22][1:0]));

   // assign value to the relevant output
   assign en_sw_test_rep_q[1:0] = regs_q[22][1:0]; 
   // pad the config bus with zeros
   assign regs_q[22][31:2] = '0; 
   
   // register #23 --- name:sel_pfd_in, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[23] = onehot_en[23]; 
   // input only from cfg bus
   assign regs_d[23][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  sel_pfd_in_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[23]),
      .din(regs_d[23][0:0]), .dout(regs_q[23][0:0]));

   // assign value to the relevant output
   assign sel_pfd_in_q[0:0] = regs_q[23][0:0]; 
   // pad the config bus with zeros
   assign regs_q[23][31:1] = '0; 
   
   // register #24 --- name:sel_pfd_in_meas, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[24] = onehot_en[24]; 
   // input only from cfg bus
   assign regs_d[24][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  sel_pfd_in_meas_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[24]),
      .din(regs_d[24][0:0]), .dout(regs_q[24][0:0]));

   // assign value to the relevant output
   assign sel_pfd_in_meas_q[0:0] = regs_q[24][0:0]; 
   // pad the config bus with zeros
   assign regs_q[24][31:1] = '0; 
   
   // register #25 --- name:en_pfd_inp_meas, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[25] = onehot_en[25]; 
   // input only from cfg bus
   assign regs_d[25][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_pfd_inp_meas_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[25]),
      .din(regs_d[25][0:0]), .dout(regs_q[25][0:0]));

   // assign value to the relevant output
   assign en_pfd_inp_meas_q[0:0] = regs_q[25][0:0]; 
   // pad the config bus with zeros
   assign regs_q[25][31:1] = '0; 
   
   // register #26 --- name:en_pfd_inn_meas, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[26] = onehot_en[26]; 
   // input only from cfg bus
   assign regs_d[26][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_pfd_inn_meas_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[26]),
      .din(regs_d[26][0:0]), .dout(regs_q[26][0:0]));

   // assign value to the relevant output
   assign en_pfd_inn_meas_q[0:0] = regs_q[26][0:0]; 
   // pad the config bus with zeros
   assign regs_q[26][31:1] = '0; 
   
   // register #27 --- name:sel_del_out, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[27] = onehot_en[27]; 
   // input only from cfg bus
   assign regs_d[27][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  sel_del_out_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[27]),
      .din(regs_d[27][0:0]), .dout(regs_q[27][0:0]));

   // assign value to the relevant output
   assign sel_del_out_q[0:0] = regs_q[27][0:0]; 
   // pad the config bus with zeros
   assign regs_q[27][31:1] = '0; 
   
   // register #28 --- name:disable_ibuf_async, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[28] = onehot_en[28]; 
   // input only from cfg bus
   assign regs_d[28][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  disable_ibuf_async_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[28]),
      .din(regs_d[28][0:0]), .dout(regs_q[28][0:0]));

   // assign value to the relevant output
   assign disable_ibuf_async_q[0:0] = regs_q[28][0:0]; 
   // pad the config bus with zeros
   assign regs_q[28][31:1] = '0; 
   
   // register #29 --- name:disable_ibuf_aux, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[29] = onehot_en[29]; 
   // input only from cfg bus
   assign regs_d[29][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  disable_ibuf_aux_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[29]),
      .din(regs_d[29][0:0]), .dout(regs_q[29][0:0]));

   // assign value to the relevant output
   assign disable_ibuf_aux_q[0:0] = regs_q[29][0:0]; 
   // pad the config bus with zeros
   assign regs_q[29][31:1] = '0; 
   
   // register #30 --- name:disable_ibuf_test0, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[30] = onehot_en[30]; 
   // input only from cfg bus
   assign regs_d[30][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  disable_ibuf_test0_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[30]),
      .din(regs_d[30][0:0]), .dout(regs_q[30][0:0]));

   // assign value to the relevant output
   assign disable_ibuf_test0_q[0:0] = regs_q[30][0:0]; 
   // pad the config bus with zeros
   assign regs_q[30][31:1] = '0; 
   
   // register #31 --- name:disable_ibuf_test1, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[31] = onehot_en[31]; 
   // input only from cfg bus
   assign regs_d[31][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  disable_ibuf_test1_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[31]),
      .din(regs_d[31][0:0]), .dout(regs_q[31][0:0]));

   // assign value to the relevant output
   assign disable_ibuf_test1_q[0:0] = regs_q[31][0:0]; 
   // pad the config bus with zeros
   assign regs_q[31][31:1] = '0; 
   
   // register #32 --- name:en_inbuf, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[32] = onehot_en[32]; 
   // input only from cfg bus
   assign regs_d[32][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_inbuf_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[32]),
      .din(regs_d[32][0:0]), .dout(regs_q[32][0:0]));

   // assign value to the relevant output
   assign en_inbuf_q[0:0] = regs_q[32][0:0]; 
   // pad the config bus with zeros
   assign regs_q[32][31:1] = '0; 
   
   // register #33 --- name:sel_inbuf_in, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[33] = onehot_en[33]; 
   // input only from cfg bus
   assign regs_d[33][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  sel_inbuf_in_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[33]),
      .din(regs_d[33][0:0]), .dout(regs_q[33][0:0]));

   // assign value to the relevant output
   assign sel_inbuf_in_q[0:0] = regs_q[33][0:0]; 
   // pad the config bus with zeros
   assign regs_q[33][31:1] = '0; 
   
   // register #34 --- name:bypass_inbuf_div, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[34] = onehot_en[34]; 
   // input only from cfg bus
   assign regs_d[34][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  bypass_inbuf_div_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[34]),
      .din(regs_d[34][0:0]), .dout(regs_q[34][0:0]));

   // assign value to the relevant output
   assign bypass_inbuf_div_q[0:0] = regs_q[34][0:0]; 
   // pad the config bus with zeros
   assign regs_q[34][31:1] = '0; 
   
   // register #35 --- name:inbuf_ndiv, type:o, Width:3
   // flop input only on cfg writes
   assign regs_en[35] = onehot_en[35]; 
   // input only from cfg bus
   assign regs_d[35][2:0] = cfgIn_data_del[2:0]; 
   flop_unq17  inbuf_ndiv_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[35]),
      .din(regs_d[35][2:0]), .dout(regs_q[35][2:0]));

   // assign value to the relevant output
   assign inbuf_ndiv_q[2:0] = regs_q[35][2:0]; 
   // pad the config bus with zeros
   assign regs_q[35][31:3] = '0; 
   
   // register #36 --- name:en_inbuf_meas, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[36] = onehot_en[36]; 
   // input only from cfg bus
   assign regs_d[36][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_inbuf_meas_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[36]),
      .din(regs_d[36][0:0]), .dout(regs_q[36][0:0]));

   // assign value to the relevant output
   assign en_inbuf_meas_q[0:0] = regs_q[36][0:0]; 
   // pad the config bus with zeros
   assign regs_q[36][31:1] = '0; 
   
   // register #37 --- name:en_biasgen, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[37] = onehot_en[37]; 
   // input only from cfg bus
   assign regs_d[37][3:0] = cfgIn_data_del[3:0]; 
   flop_unq18  en_biasgen_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[37]),
      .din(regs_d[37][3:0]), .dout(regs_q[37][3:0]));

   // assign value to the relevant output
   assign en_biasgen_q[3:0] = regs_q[37][3:0]; 
   // pad the config bus with zeros
   assign regs_q[37][31:4] = '0; 
   
   // register #38 --- name:sel_del_out_pi, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[38] = onehot_en[38]; 
   // input only from cfg bus
   assign regs_d[38][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  sel_del_out_pi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[38]),
      .din(regs_d[38][0:0]), .dout(regs_q[38][0:0]));

   // assign value to the relevant output
   assign sel_del_out_pi_q[0:0] = regs_q[38][0:0]; 
   // pad the config bus with zeros
   assign regs_q[38][31:1] = '0; 
   
   // register #39 --- name:en_del_out_pi, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[39] = onehot_en[39]; 
   // input only from cfg bus
   assign regs_d[39][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_del_out_pi_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[39]),
      .din(regs_d[39][0:0]), .dout(regs_q[39][0:0]));

   // assign value to the relevant output
   assign en_del_out_pi_q[0:0] = regs_q[39][0:0]; 
   // pad the config bus with zeros
   assign regs_q[39][31:1] = '0; 
   
   // register #40 --- name:pd_offset_ext, type:o, Width:8
   // flop input only on cfg writes
   assign regs_en[40] = onehot_en[40]; 
   // input only from cfg bus
   assign regs_d[40][7:0] = cfgIn_data_del[7:0]; 
   flop_unq10  pd_offset_ext_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[40]),
      .din(regs_d[40][7:0]), .dout(regs_q[40][7:0]));

   // assign value to the relevant output
   assign pd_offset_ext_q[7:0] = regs_q[40][7:0]; 
   // pad the config bus with zeros
   assign regs_q[40][31:8] = '0; 
   
   // register #41 --- name:i_val, type:o, Width:22
   // flop input only on cfg writes
   assign regs_en[41] = onehot_en[41]; 
   // input only from cfg bus
   assign regs_d[41][21:0] = cfgIn_data_del[21:0]; 
   flop_unq19  i_val_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[41]),
      .din(regs_d[41][21:0]), .dout(regs_q[41][21:0]));

   // assign value to the relevant output
   assign i_val_q[21:0] = regs_q[41][21:0]; 
   // pad the config bus with zeros
   assign regs_q[41][31:22] = '0; 
   
   // register #42 --- name:p_val, type:o, Width:22
   // flop input only on cfg writes
   assign regs_en[42] = onehot_en[42]; 
   // input only from cfg bus
   assign regs_d[42][21:0] = cfgIn_data_del[21:0]; 
   flop_unq20  p_val_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[42]),
      .din(regs_d[42][21:0]), .dout(regs_q[42][21:0]));

   // assign value to the relevant output
   assign p_val_q[21:0] = regs_q[42][21:0]; 
   // pad the config bus with zeros
   assign regs_q[42][31:22] = '0; 
   
   // register #43 --- name:en_ext_pi_ctl_cdr, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[43] = onehot_en[43]; 
   // input only from cfg bus
   assign regs_d[43][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  en_ext_pi_ctl_cdr_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[43]),
      .din(regs_d[43][0:0]), .dout(regs_q[43][0:0]));

   // assign value to the relevant output
   assign en_ext_pi_ctl_cdr_q[0:0] = regs_q[43][0:0]; 
   // pad the config bus with zeros
   assign regs_q[43][31:1] = '0; 
   
   // register #44 --- name:ext_pi_ctl_cdr, type:o, Width:9
   // flop input only on cfg writes
   assign regs_en[44] = onehot_en[44]; 
   // input only from cfg bus
   assign regs_d[44][8:0] = cfgIn_data_del[8:0]; 
   flop_unq21  ext_pi_ctl_cdr_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[44]),
      .din(regs_d[44][8:0]), .dout(regs_q[44][8:0]));

   // assign value to the relevant output
   assign ext_pi_ctl_cdr_q[8:0] = regs_q[44][8:0]; 
   // pad the config bus with zeros
   assign regs_q[44][31:9] = '0; 
   
   // register #45 --- name:en_ext_pfd_offset, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[45] = onehot_en[45]; 
   // input only from cfg bus
   assign regs_d[45][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  en_ext_pfd_offset_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[45]),
      .din(regs_d[45][0:0]), .dout(regs_q[45][0:0]));

   // assign value to the relevant output
   assign en_ext_pfd_offset_q[0:0] = regs_q[45][0:0]; 
   // pad the config bus with zeros
   assign regs_q[45][31:1] = '0; 
   
   // register #46 --- name:en_ext_pfd_offset_rep, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[46] = onehot_en[46]; 
   // input only from cfg bus
   assign regs_d[46][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  en_ext_pfd_offset_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[46]),
      .din(regs_d[46][0:0]), .dout(regs_q[46][0:0]));

   // assign value to the relevant output
   assign en_ext_pfd_offset_rep_q[0:0] = regs_q[46][0:0]; 
   // pad the config bus with zeros
   assign regs_q[46][31:1] = '0; 
   
   // register #47 --- name:en_ext_max_sel_mux, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[47] = onehot_en[47]; 
   // input only from cfg bus
   assign regs_d[47][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  en_ext_max_sel_mux_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[47]),
      .din(regs_d[47][0:0]), .dout(regs_q[47][0:0]));

   // assign value to the relevant output
   assign en_ext_max_sel_mux_q[0:0] = regs_q[47][0:0]; 
   // pad the config bus with zeros
   assign regs_q[47][31:1] = '0; 
   
   // register #48 --- name:en_pfd_cal, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[48] = onehot_en[48]; 
   // input only from cfg bus
   assign regs_d[48][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_pfd_cal_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[48]),
      .din(regs_d[48][0:0]), .dout(regs_q[48][0:0]));

   // assign value to the relevant output
   assign en_pfd_cal_q[0:0] = regs_q[48][0:0]; 
   // pad the config bus with zeros
   assign regs_q[48][31:1] = '0; 
   
   // register #49 --- name:en_pfd_cal_rep, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[49] = onehot_en[49]; 
   // input only from cfg bus
   assign regs_d[49][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_pfd_cal_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[49]),
      .din(regs_d[49][0:0]), .dout(regs_q[49][0:0]));

   // assign value to the relevant output
   assign en_pfd_cal_rep_q[0:0] = regs_q[49][0:0]; 
   // pad the config bus with zeros
   assign regs_q[49][31:1] = '0; 
   
   // register #50 --- name:Navg_adc, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[50] = onehot_en[50]; 
   // input only from cfg bus
   assign regs_d[50][3:0] = cfgIn_data_del[3:0]; 
   flop_unq22  Navg_adc_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[50]),
      .din(regs_d[50][3:0]), .dout(regs_q[50][3:0]));

   // assign value to the relevant output
   assign Navg_adc_q[3:0] = regs_q[50][3:0]; 
   // pad the config bus with zeros
   assign regs_q[50][31:4] = '0; 
   
   // register #51 --- name:Nbin_adc, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[51] = onehot_en[51]; 
   // input only from cfg bus
   assign regs_d[51][3:0] = cfgIn_data_del[3:0]; 
   flop_unq23  Nbin_adc_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[51]),
      .din(regs_d[51][3:0]), .dout(regs_q[51][3:0]));

   // assign value to the relevant output
   assign Nbin_adc_q[3:0] = regs_q[51][3:0]; 
   // pad the config bus with zeros
   assign regs_q[51][31:4] = '0; 
   
   // register #52 --- name:DZ_hist_adc, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[52] = onehot_en[52]; 
   // input only from cfg bus
   assign regs_d[52][3:0] = cfgIn_data_del[3:0]; 
   flop_unq24  DZ_hist_adc_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[52]),
      .din(regs_d[52][3:0]), .dout(regs_q[52][3:0]));

   // assign value to the relevant output
   assign DZ_hist_adc_q[3:0] = regs_q[52][3:0]; 
   // pad the config bus with zeros
   assign regs_q[52][31:4] = '0; 
   
   // register #53 --- name:Navg_adc_rep, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[53] = onehot_en[53]; 
   // input only from cfg bus
   assign regs_d[53][3:0] = cfgIn_data_del[3:0]; 
   flop_unq22  Navg_adc_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[53]),
      .din(regs_d[53][3:0]), .dout(regs_q[53][3:0]));

   // assign value to the relevant output
   assign Navg_adc_rep_q[3:0] = regs_q[53][3:0]; 
   // pad the config bus with zeros
   assign regs_q[53][31:4] = '0; 
   
   // register #54 --- name:Nbin_adc_rep, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[54] = onehot_en[54]; 
   // input only from cfg bus
   assign regs_d[54][3:0] = cfgIn_data_del[3:0]; 
   flop_unq23  Nbin_adc_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[54]),
      .din(regs_d[54][3:0]), .dout(regs_q[54][3:0]));

   // assign value to the relevant output
   assign Nbin_adc_rep_q[3:0] = regs_q[54][3:0]; 
   // pad the config bus with zeros
   assign regs_q[54][31:4] = '0; 
   
   // register #55 --- name:DZ_hist_adc_rep, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[55] = onehot_en[55]; 
   // input only from cfg bus
   assign regs_d[55][3:0] = cfgIn_data_del[3:0]; 
   flop_unq24  DZ_hist_adc_rep_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[55]),
      .din(regs_d[55][3:0]), .dout(regs_q[55][3:0]));

   // assign value to the relevant output
   assign DZ_hist_adc_rep_q[3:0] = regs_q[55][3:0]; 
   // pad the config bus with zeros
   assign regs_q[55][31:4] = '0; 
   
   // register #56 --- name:Ndiv_clk_avg, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[56] = onehot_en[56]; 
   // input only from cfg bus
   assign regs_d[56][3:0] = cfgIn_data_del[3:0]; 
   flop_unq22  Ndiv_clk_avg_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[56]),
      .din(regs_d[56][3:0]), .dout(regs_q[56][3:0]));

   // assign value to the relevant output
   assign Ndiv_clk_avg_q[3:0] = regs_q[56][3:0]; 
   // pad the config bus with zeros
   assign regs_q[56][31:4] = '0; 
   
   // register #57 --- name:Ndiv_clk_cdr, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[57] = onehot_en[57]; 
   // input only from cfg bus
   assign regs_d[57][3:0] = cfgIn_data_del[3:0]; 
   flop_unq25  Ndiv_clk_cdr_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[57]),
      .din(regs_d[57][3:0]), .dout(regs_q[57][3:0]));

   // assign value to the relevant output
   assign Ndiv_clk_cdr_q[3:0] = regs_q[57][3:0]; 
   // pad the config bus with zeros
   assign regs_q[57][31:4] = '0; 
   
   // register #58 --- name:int_rstb, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[58] = onehot_en[58]; 
   // input only from cfg bus
   assign regs_d[58][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  int_rstb_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[58]),
      .din(regs_d[58][0:0]), .dout(regs_q[58][0:0]));

   // assign value to the relevant output
   assign int_rstb_q[0:0] = regs_q[58][0:0]; 
   // pad the config bus with zeros
   assign regs_q[58][31:1] = '0; 
   
   // register #59 --- name:sram_rstb, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[59] = onehot_en[59]; 
   // input only from cfg bus
   assign regs_d[59][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  sram_rstb_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[59]),
      .din(regs_d[59][0:0]), .dout(regs_q[59][0:0]));

   // assign value to the relevant output
   assign sram_rstb_q[0:0] = regs_q[59][0:0]; 
   // pad the config bus with zeros
   assign regs_q[59][31:1] = '0; 
   
   // register #60 --- name:cdr_rstb, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[60] = onehot_en[60]; 
   // input only from cfg bus
   assign regs_d[60][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  cdr_rstb_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[60]),
      .din(regs_d[60][0:0]), .dout(regs_q[60][0:0]));

   // assign value to the relevant output
   assign cdr_rstb_q[0:0] = regs_q[60][0:0]; 
   // pad the config bus with zeros
   assign regs_q[60][31:1] = '0; 
   
   // register #61 --- name:sel_outbuff, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[61] = onehot_en[61]; 
   // input only from cfg bus
   assign regs_d[61][3:0] = cfgIn_data_del[3:0]; 
   flop_unq6  sel_outbuff_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[61]),
      .din(regs_d[61][3:0]), .dout(regs_q[61][3:0]));

   // assign value to the relevant output
   assign sel_outbuff_q[3:0] = regs_q[61][3:0]; 
   // pad the config bus with zeros
   assign regs_q[61][31:4] = '0; 
   
   // register #62 --- name:sel_trigbuff, type:o, Width:4
   // flop input only on cfg writes
   assign regs_en[62] = onehot_en[62]; 
   // input only from cfg bus
   assign regs_d[62][3:0] = cfgIn_data_del[3:0]; 
   flop_unq6  sel_trigbuff_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[62]),
      .din(regs_d[62][3:0]), .dout(regs_q[62][3:0]));

   // assign value to the relevant output
   assign sel_trigbuff_q[3:0] = regs_q[62][3:0]; 
   // pad the config bus with zeros
   assign regs_q[62][31:4] = '0; 
   
   // register #63 --- name:en_outbuff, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[63] = onehot_en[63]; 
   // input only from cfg bus
   assign regs_d[63][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_outbuff_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[63]),
      .din(regs_d[63][0:0]), .dout(regs_q[63][0:0]));

   // assign value to the relevant output
   assign en_outbuff_q[0:0] = regs_q[63][0:0]; 
   // pad the config bus with zeros
   assign regs_q[63][31:1] = '0; 
   
   // register #64 --- name:en_trigbuff, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[64] = onehot_en[64]; 
   // input only from cfg bus
   assign regs_d[64][0:0] = cfgIn_data_del[0:0]; 
   flop_unq13  en_trigbuff_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[64]),
      .din(regs_d[64][0:0]), .dout(regs_q[64][0:0]));

   // assign value to the relevant output
   assign en_trigbuff_q[0:0] = regs_q[64][0:0]; 
   // pad the config bus with zeros
   assign regs_q[64][31:1] = '0; 
   
   // register #65 --- name:Ndiv_outbuff, type:o, Width:3
   // flop input only on cfg writes
   assign regs_en[65] = onehot_en[65]; 
   // input only from cfg bus
   assign regs_d[65][2:0] = cfgIn_data_del[2:0]; 
   flop_unq17  Ndiv_outbuff_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[65]),
      .din(regs_d[65][2:0]), .dout(regs_q[65][2:0]));

   // assign value to the relevant output
   assign Ndiv_outbuff_q[2:0] = regs_q[65][2:0]; 
   // pad the config bus with zeros
   assign regs_q[65][31:3] = '0; 
   
   // register #66 --- name:Ndiv_trigbuff, type:o, Width:3
   // flop input only on cfg writes
   assign regs_en[66] = onehot_en[66]; 
   // input only from cfg bus
   assign regs_d[66][2:0] = cfgIn_data_del[2:0]; 
   flop_unq17  Ndiv_trigbuff_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[66]),
      .din(regs_d[66][2:0]), .dout(regs_q[66][2:0]));

   // assign value to the relevant output
   assign Ndiv_trigbuff_q[2:0] = regs_q[66][2:0]; 
   // pad the config bus with zeros
   assign regs_q[66][31:3] = '0; 
   
   // register #67 --- name:bypass_out, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[67] = onehot_en[67]; 
   // input only from cfg bus
   assign regs_d[67][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  bypass_out_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[67]),
      .din(regs_d[67][0:0]), .dout(regs_q[67][0:0]));

   // assign value to the relevant output
   assign bypass_out_q[0:0] = regs_q[67][0:0]; 
   // pad the config bus with zeros
   assign regs_q[67][31:1] = '0; 
   
   // register #68 --- name:bypass_trig, type:o, Width:1
   // flop input only on cfg writes
   assign regs_en[68] = onehot_en[68]; 
   // input only from cfg bus
   assign regs_d[68][0:0] = cfgIn_data_del[0:0]; 
   flop_unq15  bypass_trig_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[68]),
      .din(regs_d[68][0:0]), .dout(regs_q[68][0:0]));

   // assign value to the relevant output
   assign bypass_trig_q[0:0] = regs_q[68][0:0]; 
   // pad the config bus with zeros
   assign regs_q[68][31:1] = '0; 
   
   // register #69 --- name:in_addr, type:o, Width:10
   // flop input only on cfg writes
   assign regs_en[69] = onehot_en[69]; 
   // input only from cfg bus
   assign regs_d[69][9:0] = cfgIn_data_del[9:0]; 
   flop_unq7  in_addr_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[69]),
      .din(regs_d[69][9:0]), .dout(regs_q[69][9:0]));

   // assign value to the relevant output
   assign in_addr_q[9:0] = regs_q[69][9:0]; 
   // pad the config bus with zeros
   assign regs_q[69][31:10] = '0; 
   
endmodule: reg_file_unq18
