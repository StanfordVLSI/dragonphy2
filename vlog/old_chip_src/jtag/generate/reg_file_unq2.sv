//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11879 $ --- $Date: 2013/06/11 $   |
//	-----------------------------------------------
//	
//
//  Source file: /sim/zamyers/JusTAG/rtl/primitives/reg_file.svp
//  Source template: reg_file
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter RegList 	= Data structure of type ARRAY
// Parameter CfgOpcodes 	= Data structure of type HASH
// Parameter BaseAddr 	= 4608
// Parameter CfgBusPtr 	= Data structure of type cfg_ifc
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/* *****************************************************************************
 * File: reg_file.vp
 * 
 * Description:
 * This file is using Genesis2 to make a register file.
 * A register file have a config bus input port, and a config bus output port. 
 * The configuration request values are flopped and then handled:
 * * If cfgIn_op is a no-op, nothing happens.
 * * If cfgIn_op is a bypass op, the  cfgIn_* signals are passed to the 
 *      cfgOut_* ports.
 * * If cfgIn_op is a read/write op, and cfgIn_addr is with in the address
 *      range, then the corresponding register is read/written. The values
 *      are streamed to the cfgOut_* ports, except for cfgOut_op that becomes
 *      a bypass-op.
 *      If cfgIn_addr is not in this reg_file address range, all the  cfgIn_* 
 *      signals are passed to the cfgOut_* ports. Someone else will answer...
 * 
 * Note: All registers in the register file are write-able and readable by the
 *      configuration bus (even though some may only have output ports or only
 *      input ports).
 * 
 * 
 * REQUIRED GENESIS PARAMETERS:
 * ----------------------------
 * * RegList  - List of registers. Each element in the list is a hash that contains
 *    * Name - used for generating the enable and data output/input signals
 *    * Width - register width
 *    * Default - (optional) default value. Can be set later by XML input
 *    * IEO - I indicates this register connected to an input signal
 *            E indicates that the input is qualified by an enable 
 *            O indicates that the output is connected to an output signal
 *            Valid options include: I, IE, O, IO, IEO
 *    * Comment - (optional) description of the register
 *   Example:
 *    my $reg_list = [      
 *        {Name => 'regA', Width => 5, Default => 17, IEO => 'ie', Comment => 'this is a reg'}, 
 *        {Name => 'regB', Width => 10, Default => 27, IEO => 'o'}, 
 *        {Name => 'regC', Width => 15, IEO => 'ieo'},
 *        {Name => 'regD', Width => 13, Default => 4, IEO => 'i'}
 *                   ];
 * 
 * * BaseAddr - Base address for this module 
 * * CfgOpcodes - Interpretation of the opcode. Must contain the following feilds:
 *    * nop - value of cfgIn_op for a no-op (default is 0)
 *    * read - value of cfgIn_op for a read operation (default is 1)
 *    * write - value of cfgIn_op for a write operation (default is 2)
 *    * bypass - value of cfgIn_op for bypassing the control signals (default is 3)
 * * CfgBusPtr - An instance of the reg_file_ifc (used as reference)
 * 
 * Inputs:
 * -------
 * Clk
 * Reset
 * cfgIn - Incomming config request
 * foreach REG in REG_LIST (but depending on the IEO flag):
 *  * <REG.name>_en - enable signal for the register
 *  * <REG.name>_d - data input for the register
 * 
 * Outputs:
 * --------
 * cfgOut - Outgoing reply for config request cfgIn
 * foreach REG in REG_LIST (but depending on the IEO flag):
 *  * <REG.name>_q - data output for the register
 * 
 * 
 * NOTE: registers with input from the design may become resource contention
 *       if both their private enable and their by-address enable signals are raised.
 *       Priority is always given to data from the cfg bus!
 * 
 * ****************************************************************************/

// ACTUAL GENESIS2 PARAMETERIZATIONS
// RegList (_GENESIS2_INHERITANCE_PRIORITY_) = 
//	[ { IEO=>i, Name=>pm_out_0, Width=>20 },
//	  { IEO=>i, Name=>pm_out_1, Width=>20 },
//	  { IEO=>i, Name=>pm_out_2, Width=>20 },
//	  { IEO=>i, Name=>pm_out_3, Width=>20 },
//	  { IEO=>i, Name=>pm_out_4, Width=>20 },
//	  { IEO=>i, Name=>pm_out_5, Width=>20 },
//	  { IEO=>i, Name=>pm_out_6, Width=>20 },
//	  { IEO=>i, Name=>pm_out_7, Width=>20 },
//	  { IEO=>i, Name=>pm_out_8, Width=>20 },
//	  { IEO=>i, Name=>pm_out_9, Width=>20 },
//	  { IEO=>i, Name=>pm_out_10, Width=>20 },
//	  { IEO=>i, Name=>pm_out_11, Width=>20 },
//	  { IEO=>i, Name=>pm_out_12, Width=>20 },
//	  { IEO=>i, Name=>pm_out_13, Width=>20 },
//	  { IEO=>i, Name=>pm_out_14, Width=>20 },
//	  { IEO=>i, Name=>pm_out_15, Width=>20 }
//	]
//
// BaseAddr (_GENESIS2_INHERITANCE_PRIORITY_) = 0x1200
//
// CfgOpcodes (_GENESIS2_INHERITANCE_PRIORITY_) = 
//	{ bypass=>3, nop=>0, read=>1, write=>2 }
//
// CfgBusPtr (_GENESIS2_INHERITANCE_PRIORITY_) = 
//	InstancePath:raw_jtag.sc_jtag2rf0_ifc (cfg_ifc_unq1)
//

// Fix for reg files with single registers
// 13:6
// 8
// 72
// 8'h48
// =============================================================================
//                  LIST OF REGISTERS IN THIS MODULE:
// =============================================================================
// LEGEND: 
//      BaseAddr 'h1200
//      IEO:  I for input (register samples design)
//            O for output (register drives design)
//            IE for enabled input (register samples design if enable is high)
//
// REGISTERS
// pm_out_0 [19:0] IEO=i Offset=0 -- 
// pm_out_1 [19:0] IEO=i Offset=4 -- 
// pm_out_2 [19:0] IEO=i Offset=8 -- 
// pm_out_3 [19:0] IEO=i Offset=12 -- 
// pm_out_4 [19:0] IEO=i Offset=16 -- 
// pm_out_5 [19:0] IEO=i Offset=20 -- 
// pm_out_6 [19:0] IEO=i Offset=24 -- 
// pm_out_7 [19:0] IEO=i Offset=28 -- 
// pm_out_8 [19:0] IEO=i Offset=32 -- 
// pm_out_9 [19:0] IEO=i Offset=36 -- 
// pm_out_10 [19:0] IEO=i Offset=40 -- 
// pm_out_11 [19:0] IEO=i Offset=44 -- 
// pm_out_12 [19:0] IEO=i Offset=48 -- 
// pm_out_13 [19:0] IEO=i Offset=52 -- 
// pm_out_14 [19:0] IEO=i Offset=56 -- 
// pm_out_15 [19:0] IEO=i Offset=60 -- 




// =============================================================================
//                             MODULE:
// =============================================================================
module reg_file_unq2
  (
   // inputs for the config interface
   cfg_ifc_unq1.cfgIn cfgIn, // incoming requests
   cfg_ifc_unq1.cfgOut cfgOut, // outgoing responds

    // inputs for register pm_out_0
    input wire logic [19:0]       pm_out_0_d,

    // inputs for register pm_out_1
    input wire logic [19:0]       pm_out_1_d,

    // inputs for register pm_out_2
    input wire logic [19:0]       pm_out_2_d,

    // inputs for register pm_out_3
    input wire logic [19:0]       pm_out_3_d,

    // inputs for register pm_out_4
    input wire logic [19:0]       pm_out_4_d,

    // inputs for register pm_out_5
    input wire logic [19:0]       pm_out_5_d,

    // inputs for register pm_out_6
    input wire logic [19:0]       pm_out_6_d,

    // inputs for register pm_out_7
    input wire logic [19:0]       pm_out_7_d,

    // inputs for register pm_out_8
    input wire logic [19:0]       pm_out_8_d,

    // inputs for register pm_out_9
    input wire logic [19:0]       pm_out_9_d,

    // inputs for register pm_out_10
    input wire logic [19:0]       pm_out_10_d,

    // inputs for register pm_out_11
    input wire logic [19:0]       pm_out_11_d,

    // inputs for register pm_out_12
    input wire logic [19:0]       pm_out_12_d,

    // inputs for register pm_out_13
    input wire logic [19:0]       pm_out_13_d,

    // inputs for register pm_out_14
    input wire logic [19:0]       pm_out_14_d,

    // inputs for register pm_out_15
    input wire logic [19:0]       pm_out_15_d,


   //outputs
   
   // Generic inputs 
    input wire logic			       Clk,
    input wire logic                        Reset
   );


   // floping cfg inputs to produce delayed signals:
   logic [13:0]       cfgIn_addr_del;
   logic [31:0]        cfgIn_data_del;
   logic [1:0]         cfgIn_op_del;
   flop_unq5  cfgIn_floper (.Clk(Clk), .Reset(Reset), 
			      .din({cfgIn.addr, cfgIn.data, cfgIn.op}),
			      .dout({cfgIn_addr_del, cfgIn_data_del, cfgIn_op_del}));



   // internal wiring signals
   logic [15:0]             onehot_en;
   logic                               addr_in_range;
   logic [3:0]    cfgIn_addr_del_int; // internal (shorter) address signal
   logic [15:0]             regs_en;
   logic [31:0]        regs_d[15:0];
   logic [31:0]        regs_q[15:0];

   // make sure that the input address is in range
   assign addr_in_range = ((8'h48 == cfgIn_addr_del[13:6]) &&
                     (cfgIn_addr_del[5:2] < 5'd16))? 1'b1: 1'b0;
   
   // Pick the right bits of the address signal (if out of range default to zero)
   assign cfgIn_addr_del_int[3:0] = (addr_in_range)? cfgIn_addr_del[5:2]: 4'b0;
   
   // For config writes, there can be at most onehot enable signal
   always_comb begin
      onehot_en = 1'b0;
      onehot_en[cfgIn_addr_del_int] = (cfgIn_op_del == 2) && (addr_in_range == 1'b1);
   end

   // assign the config output ports
   assign cfgOut.data = (addr_in_range != 1'b1) ? cfgIn_data_del : // if not in range, pass the signal to the next guy
                  (cfgIn_op_del == 1) ? regs_q[cfgIn_addr_del_int] : // if in range and this is a readop... read
                  cfgIn_data_del;
   assign cfgOut.addr = cfgIn_addr_del;
   assign cfgOut.op = (addr_in_range != 1'b1) ? cfgIn_op_del : // if not in range pass the signal to next guy
                  (cfgIn_op_del != 0) ? 2'd3:      // if in range (and not a nop) mark as done (bypass)
                  2'd0;                              // else, it's just a nop.
      

   // Instantiate all the registers:
   // ==============================
   // register #0 --- name:pm_out_0, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[0] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[0][19:0] = (onehot_en[0])?cfgIn_data_del[19:0]:
                                                                  pm_out_0_d[19:0]; 
   flop_unq8  pm_out_0_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[0]),
      .din(regs_d[0][19:0]), .dout(regs_q[0][19:0]));

   // pad the config bus with zeros
   assign regs_q[0][31:20] = '0; 
   
   // register #1 --- name:pm_out_1, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[1] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[1][19:0] = (onehot_en[1])?cfgIn_data_del[19:0]:
                                                                  pm_out_1_d[19:0]; 
   flop_unq8  pm_out_1_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[1]),
      .din(regs_d[1][19:0]), .dout(regs_q[1][19:0]));

   // pad the config bus with zeros
   assign regs_q[1][31:20] = '0; 
   
   // register #2 --- name:pm_out_2, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[2] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[2][19:0] = (onehot_en[2])?cfgIn_data_del[19:0]:
                                                                  pm_out_2_d[19:0]; 
   flop_unq8  pm_out_2_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[2]),
      .din(regs_d[2][19:0]), .dout(regs_q[2][19:0]));

   // pad the config bus with zeros
   assign regs_q[2][31:20] = '0; 
   
   // register #3 --- name:pm_out_3, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[3] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[3][19:0] = (onehot_en[3])?cfgIn_data_del[19:0]:
                                                                  pm_out_3_d[19:0]; 
   flop_unq8  pm_out_3_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[3]),
      .din(regs_d[3][19:0]), .dout(regs_q[3][19:0]));

   // pad the config bus with zeros
   assign regs_q[3][31:20] = '0; 
   
   // register #4 --- name:pm_out_4, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[4] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[4][19:0] = (onehot_en[4])?cfgIn_data_del[19:0]:
                                                                  pm_out_4_d[19:0]; 
   flop_unq8  pm_out_4_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[4]),
      .din(regs_d[4][19:0]), .dout(regs_q[4][19:0]));

   // pad the config bus with zeros
   assign regs_q[4][31:20] = '0; 
   
   // register #5 --- name:pm_out_5, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[5] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[5][19:0] = (onehot_en[5])?cfgIn_data_del[19:0]:
                                                                  pm_out_5_d[19:0]; 
   flop_unq8  pm_out_5_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[5]),
      .din(regs_d[5][19:0]), .dout(regs_q[5][19:0]));

   // pad the config bus with zeros
   assign regs_q[5][31:20] = '0; 
   
   // register #6 --- name:pm_out_6, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[6] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[6][19:0] = (onehot_en[6])?cfgIn_data_del[19:0]:
                                                                  pm_out_6_d[19:0]; 
   flop_unq8  pm_out_6_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[6]),
      .din(regs_d[6][19:0]), .dout(regs_q[6][19:0]));

   // pad the config bus with zeros
   assign regs_q[6][31:20] = '0; 
   
   // register #7 --- name:pm_out_7, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[7] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[7][19:0] = (onehot_en[7])?cfgIn_data_del[19:0]:
                                                                  pm_out_7_d[19:0]; 
   flop_unq8  pm_out_7_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[7]),
      .din(regs_d[7][19:0]), .dout(regs_q[7][19:0]));

   // pad the config bus with zeros
   assign regs_q[7][31:20] = '0; 
   
   // register #8 --- name:pm_out_8, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[8] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[8][19:0] = (onehot_en[8])?cfgIn_data_del[19:0]:
                                                                  pm_out_8_d[19:0]; 
   flop_unq8  pm_out_8_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[8]),
      .din(regs_d[8][19:0]), .dout(regs_q[8][19:0]));

   // pad the config bus with zeros
   assign regs_q[8][31:20] = '0; 
   
   // register #9 --- name:pm_out_9, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[9] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[9][19:0] = (onehot_en[9])?cfgIn_data_del[19:0]:
                                                                  pm_out_9_d[19:0]; 
   flop_unq8  pm_out_9_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[9]),
      .din(regs_d[9][19:0]), .dout(regs_q[9][19:0]));

   // pad the config bus with zeros
   assign regs_q[9][31:20] = '0; 
   
   // register #10 --- name:pm_out_10, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[10] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[10][19:0] = (onehot_en[10])?cfgIn_data_del[19:0]:
                                                                  pm_out_10_d[19:0]; 
   flop_unq8  pm_out_10_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[10]),
      .din(regs_d[10][19:0]), .dout(regs_q[10][19:0]));

   // pad the config bus with zeros
   assign regs_q[10][31:20] = '0; 
   
   // register #11 --- name:pm_out_11, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[11] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[11][19:0] = (onehot_en[11])?cfgIn_data_del[19:0]:
                                                                  pm_out_11_d[19:0]; 
   flop_unq8  pm_out_11_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[11]),
      .din(regs_d[11][19:0]), .dout(regs_q[11][19:0]));

   // pad the config bus with zeros
   assign regs_q[11][31:20] = '0; 
   
   // register #12 --- name:pm_out_12, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[12] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[12][19:0] = (onehot_en[12])?cfgIn_data_del[19:0]:
                                                                  pm_out_12_d[19:0]; 
   flop_unq8  pm_out_12_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[12]),
      .din(regs_d[12][19:0]), .dout(regs_q[12][19:0]));

   // pad the config bus with zeros
   assign regs_q[12][31:20] = '0; 
   
   // register #13 --- name:pm_out_13, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[13] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[13][19:0] = (onehot_en[13])?cfgIn_data_del[19:0]:
                                                                  pm_out_13_d[19:0]; 
   flop_unq8  pm_out_13_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[13]),
      .din(regs_d[13][19:0]), .dout(regs_q[13][19:0]));

   // pad the config bus with zeros
   assign regs_q[13][31:20] = '0; 
   
   // register #14 --- name:pm_out_14, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[14] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[14][19:0] = (onehot_en[14])?cfgIn_data_del[19:0]:
                                                                  pm_out_14_d[19:0]; 
   flop_unq8  pm_out_14_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[14]),
      .din(regs_d[14][19:0]), .dout(regs_q[14][19:0]));

   // pad the config bus with zeros
   assign regs_q[14][31:20] = '0; 
   
   // register #15 --- name:pm_out_15, type:i, Width:20
   // flop input with no qualifier
   assign regs_en[15] = 1'b1; 
   // give priority to cfg bus writes, otherwise input from module input
   assign regs_d[15][19:0] = (onehot_en[15])?cfgIn_data_del[19:0]:
                                                                  pm_out_15_d[19:0]; 
   flop_unq8  pm_out_15_reg
     (.Clk(Clk), .Reset(Reset), .en(regs_en[15]),
      .din(regs_d[15][19:0]), .dout(regs_q[15][19:0]));

   // pad the config bus with zeros
   assign regs_q[15][31:20] = '0; 
   
endmodule: reg_file_unq2
